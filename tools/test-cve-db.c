/*
 * FirmwareGuard - CVE Database Test Tool
 * Test and validate CVE correlation database functionality
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include "../src/database/cve_db.h"

/* Test database path */
#define TEST_DB_PATH "/tmp/firmwareguard_test_cve.db"
#define SEED_DATA_PATH "data/cve_firmware.json"

/* ANSI color codes for output */
#define COLOR_RESET   "\033[0m"
#define COLOR_RED     "\033[31m"
#define COLOR_GREEN   "\033[32m"
#define COLOR_YELLOW  "\033[33m"
#define COLOR_BLUE    "\033[34m"
#define COLOR_CYAN    "\033[36m"

/* Test result tracking */
static int tests_passed = 0;
static int tests_failed = 0;

/* Helper: Print test result */
static void test_result(const char *test_name, int passed)
{
    if (passed) {
        printf("%s[PASS]%s %s\n", COLOR_GREEN, COLOR_RESET, test_name);
        tests_passed++;
    } else {
        printf("%s[FAIL]%s %s\n", COLOR_RED, COLOR_RESET, test_name);
        tests_failed++;
    }
}

/* Test: Database initialization */
static int test_db_init(void)
{
    printf("\n%s=== Test: Database Initialization ===%s\n", COLOR_CYAN, COLOR_RESET);

    /* Remove old test database */
    unlink(TEST_DB_PATH);

    int ret = cve_db_init(TEST_DB_PATH);
    test_result("Database creation", ret == 0);

    int is_open = cve_db_is_open();
    test_result("Database is open", is_open);

    cve_db_close();

    int is_closed = !cve_db_is_open();
    test_result("Database is closed", is_closed);

    return ret == 0;
}

/* Test: Import seed data */
static int test_import_seed_data(void)
{
    printf("\n%s=== Test: Import Seed Data ===%s\n", COLOR_CYAN, COLOR_RESET);

    if (cve_db_init(TEST_DB_PATH) != 0) {
        test_result("Database initialization for import", 0);
        return -1;
    }

    int imported = 0, skipped = 0;
    int ret = cve_db_import_json(SEED_DATA_PATH, &imported, &skipped);

    test_result("JSON import successful", ret == 0);
    test_result("CVEs imported", imported > 0);

    printf("  Imported: %d CVEs\n", imported);
    printf("  Skipped:  %d CVEs\n", skipped);

    return ret;
}

/* Test: Get CVE by ID */
static int test_get_by_id(void)
{
    printf("\n%s=== Test: Get CVE by ID ===%s\n", COLOR_CYAN, COLOR_RESET);

    cve_entry_t entry;

    /* Test: Get known CVE */
    int ret = cve_db_get_by_id("CVE-2017-5689", &entry);
    test_result("Get CVE-2017-5689 (Silent Bob)", ret == 0);

    if (ret == 0) {
        printf("  Component: %s\n", entry.component);
        printf("  Severity:  %s (CVSS %.1f)\n",
               cve_severity_to_str(entry.severity), entry.cvss_score);
        printf("  Affected:  %s - %s\n",
               entry.version_affected_start, entry.version_affected_end);
        test_result("CVSS score is 9.8", entry.cvss_score >= 9.7 && entry.cvss_score <= 9.9);
        test_result("Marked as exploited", entry.exploited_in_wild);
    }

    /* Test: Get non-existent CVE */
    ret = cve_db_get_by_id("CVE-9999-99999", &entry);
    test_result("Get non-existent CVE fails correctly", ret != 0);

    /* Test: Invalid CVE ID format */
    ret = cve_db_get_by_id("INVALID-ID", &entry);
    test_result("Invalid CVE ID rejected", ret != 0);

    return 0;
}

/* Test: Version checking */
static int test_version_check(void)
{
    printf("\n%s=== Test: Version Vulnerability Check ===%s\n", COLOR_CYAN, COLOR_RESET);

    cve_match_t *matches = NULL;
    int count = 0;

    /* Test: Check vulnerable Intel ME version */
    int ret = cve_db_check_version("Intel ME", "11.6.20", &matches, &count);
    test_result("Check Intel ME 11.6.20", ret == 0);

    if (ret == 0 && count > 0) {
        printf("  Found %d vulnerabilities:\n", count);
        for (int i = 0; i < count; i++) {
            printf("    %s: CVSS %.1f - %s\n",
                   matches[i].cve->cve_id,
                   matches[i].cve->cvss_score,
                   matches[i].match_reason);
        }
        test_result("At least one vulnerability found", count > 0);
        cve_db_free_results(matches, count);
    }

    /* Test: Check patched version */
    ret = cve_db_check_version("Intel ME", "11.8.90", &matches, &count);
    test_result("Check patched Intel ME version", ret == 0);

    if (ret == 0) {
        printf("  Found %d vulnerabilities in patched version\n", count);
        test_result("Fewer vulnerabilities in patched version", count <= 3);
        if (count > 0) {
            cve_db_free_results(matches, count);
        }
    }

    return 0;
}

/* Test: Search by component type */
static int test_search_by_component(void)
{
    printf("\n%s=== Test: Search by Component Type ===%s\n", COLOR_CYAN, COLOR_RESET);

    cve_entry_t *entries = NULL;
    int count = 0;

    /* Test: Intel ME CVEs */
    int ret = cve_db_get_by_component(CVE_COMPONENT_INTEL_ME, &entries, &count);
    test_result("Get Intel ME CVEs", ret == 0);

    if (ret == 0) {
        printf("  Intel ME CVEs: %d\n", count);
        test_result("Intel ME CVEs found", count > 0);
        cve_db_free_entries(entries, count);
    }

    /* Test: AMD PSP CVEs */
    ret = cve_db_get_by_component(CVE_COMPONENT_AMD_PSP, &entries, &count);
    test_result("Get AMD PSP CVEs", ret == 0);

    if (ret == 0) {
        printf("  AMD PSP CVEs: %d\n", count);
        test_result("AMD PSP CVEs found", count > 0);
        cve_db_free_entries(entries, count);
    }

    /* Test: UEFI SecureBoot CVEs */
    ret = cve_db_get_by_component(CVE_COMPONENT_UEFI_SECUREBOOT, &entries, &count);
    test_result("Get UEFI SecureBoot CVEs", ret == 0);

    if (ret == 0) {
        printf("  UEFI SecureBoot CVEs: %d\n", count);
        test_result("UEFI SecureBoot CVEs found", count > 0);
        cve_db_free_entries(entries, count);
    }

    return 0;
}

/* Test: Search with filters */
static int test_search_filters(void)
{
    printf("\n%s=== Test: Search with Filters ===%s\n", COLOR_CYAN, COLOR_RESET);

    cve_match_t *matches = NULL;
    int count = 0;

    /* Test: Critical severity only */
    cve_query_opts_t opts = {0};
    opts.min_severity = CVE_SEVERITY_CRITICAL;
    opts.limit = 100;

    int ret = cve_db_search(&opts, &matches, &count);
    test_result("Search critical CVEs", ret == 0);

    if (ret == 0) {
        printf("  Critical CVEs: %d\n", count);
        test_result("Critical CVEs found", count > 0);

        /* Verify all are critical */
        int all_critical = 1;
        for (int i = 0; i < count; i++) {
            if (matches[i].cve->severity != CVE_SEVERITY_CRITICAL) {
                all_critical = 0;
                break;
            }
        }
        test_result("All results are critical", all_critical);
        cve_db_free_results(matches, count);
    }

    /* Test: Exploited in wild */
    memset(&opts, 0, sizeof(opts));
    opts.only_exploited = 1;
    opts.limit = 100;

    ret = cve_db_search(&opts, &matches, &count);
    test_result("Search exploited CVEs", ret == 0);

    if (ret == 0) {
        printf("  Exploited CVEs: %d\n", count);
        printf("  CVEs:\n");
        for (int i = 0; i < count; i++) {
            printf("    %s: %s\n", matches[i].cve->cve_id, matches[i].cve->component);
        }
        test_result("Exploited CVEs found", count > 0);
        cve_db_free_results(matches, count);
    }

    /* Test: Vendor filter */
    memset(&opts, 0, sizeof(opts));
    opts.vendor = "Intel";
    opts.limit = 100;

    ret = cve_db_search(&opts, &matches, &count);
    test_result("Search Intel CVEs", ret == 0);

    if (ret == 0) {
        printf("  Intel CVEs: %d\n", count);
        test_result("Intel CVEs found", count > 0);
        cve_db_free_results(matches, count);
    }

    return 0;
}

/* Test: Database statistics */
static int test_statistics(void)
{
    printf("\n%s=== Test: Database Statistics ===%s\n", COLOR_CYAN, COLOR_RESET);

    cve_db_stats_t stats;
    int ret = cve_db_stats(&stats);
    test_result("Get database statistics", ret == 0);

    if (ret == 0) {
        printf("  Total CVEs:      %ld\n", stats.total_cves);
        printf("  Critical CVEs:   %ld\n", stats.critical_cves);
        printf("  High CVEs:       %ld\n", stats.high_cves);
        printf("  Medium CVEs:     %ld\n", stats.medium_cves);
        printf("  Low CVEs:        %ld\n", stats.low_cves);
        printf("  Exploited CVEs:  %ld\n", stats.exploited_cves);
        printf("  Unpatched CVEs:  %ld\n", stats.unpatched_cves);
        printf("  Intel ME CVEs:   %ld\n", stats.intel_me_cves);
        printf("  AMD PSP CVEs:    %ld\n", stats.amd_psp_cves);
        printf("  UEFI CVEs:       %ld\n", stats.uefi_cves);
        printf("  Database size:   %ld bytes\n", stats.db_size_bytes);

        test_result("Total CVEs > 0", stats.total_cves > 0);
        test_result("Database size > 0", stats.db_size_bytes > 0);
    }

    /* Print formatted statistics */
    printf("\n");
    cve_print_stats(&stats);

    return 0;
}

/* Test: Version comparison */
static int test_version_comparison(void)
{
    printf("\n%s=== Test: Version Comparison ===%s\n", COLOR_CYAN, COLOR_RESET);

    /* Test: Equal versions */
    int cmp = cve_version_compare("11.6.20", "11.6.20");
    test_result("11.6.20 == 11.6.20", cmp == 0);

    /* Test: Less than */
    cmp = cve_version_compare("11.6.20", "11.6.55");
    test_result("11.6.20 < 11.6.55", cmp < 0);

    /* Test: Greater than */
    cmp = cve_version_compare("11.8.90", "11.6.20");
    test_result("11.8.90 > 11.6.20", cmp > 0);

    /* Test: Range checking */
    int in_range = cve_version_in_range("11.6.20", "11.0.0", "11.6.55");
    test_result("11.6.20 in range [11.0.0, 11.6.55]", in_range);

    in_range = cve_version_in_range("11.8.90", "11.0.0", "11.6.55");
    test_result("11.8.90 NOT in range [11.0.0, 11.6.55]", !in_range);

    in_range = cve_version_in_range("10.0.0", "11.0.0", "11.6.55");
    test_result("10.0.0 NOT in range [11.0.0, 11.6.55]", !in_range);

    return 0;
}

/* Test: Print CVE entry */
static int test_print_entry(void)
{
    printf("\n%s=== Test: Print CVE Entry ===%s\n", COLOR_CYAN, COLOR_RESET);

    cve_entry_t entry;
    int ret = cve_db_get_by_id("CVE-2022-21894", &entry);

    if (ret == 0) {
        test_result("Get BlackLotus CVE", 1);
        cve_print_entry(&entry);
    } else {
        test_result("Get BlackLotus CVE", 0);
    }

    return 0;
}

/* Main test runner */
int main(int argc, char *argv[])
{
    printf("\n");
    printf("========================================\n");
    printf("  FirmwareGuard CVE Database Tests\n");
    printf("========================================\n");

    /* Check for seed data */
    FILE *fp = fopen(SEED_DATA_PATH, "r");
    if (!fp) {
        printf("\n%sERROR: Cannot find seed data: %s%s\n", COLOR_RED, SEED_DATA_PATH, COLOR_RESET);
        printf("Run this test from the FirmwareGuard root directory.\n\n");
        return 1;
    }
    fclose(fp);

    /* Run tests */
    test_db_init();
    test_import_seed_data();
    test_get_by_id();
    test_version_check();
    test_search_by_component();
    test_search_filters();
    test_statistics();
    test_version_comparison();
    test_print_entry();

    /* Cleanup */
    cve_db_close();

    /* Print summary */
    printf("\n");
    printf("========================================\n");
    printf("  Test Summary\n");
    printf("========================================\n");
    printf("  Tests Passed: %s%d%s\n", COLOR_GREEN, tests_passed, COLOR_RESET);
    printf("  Tests Failed: %s%d%s\n", tests_failed > 0 ? COLOR_RED : COLOR_GREEN,
           tests_failed, COLOR_RESET);
    printf("  Total Tests:  %d\n", tests_passed + tests_failed);
    printf("========================================\n\n");

    /* Cleanup test database */
    if (argc > 1 && strcmp(argv[1], "--keep-db") == 0) {
        printf("Test database kept at: %s\n\n", TEST_DB_PATH);
    } else {
        unlink(TEST_DB_PATH);
    }

    return (tests_failed == 0) ? 0 : 1;
}
